<p>Many useful algorithms have a recursive structure. A common pattern that comes up is solving a problem by first breaking down the initial problem into two or more sub-problems which can be solved recursively, and then finally combining the two sub-problems together. Note that not all problems can be solved in this way</p>
<div class="definition" id="definition-divide-and-conquer">
    <div class="title">
        Divide and Conquer
    </div>
    <div class="content">
        An algorithm that solves a problem by recursively solving subproblems and then re-combining them is said to be a <b>divide and conquer</b> algorithm.
    </div>
</div>
<div class="code-file" data-file-name="implementation/merge_sort.cpp"></div>
<div class="lemma" id="lemma-merge-is-correct">
    <div class="title">
        \( \texttt{merge} \) is Correct
    </div>
    <div class="content">
        Given an array \( A \) and indices \( \textrm{left_idx}, \textrm{split_idx}, \textrm{right_idx} \) such that the subarrays \( A [ \textrm{left_idx}, ..., \textrm{split_idx} ], A [ \textrm{split_idx + 1}, ..., \textrm{right_idx} ] \) are already sorted in ascending order then after merge sort has terminated, then the subarray \( A[ \textrm{left_idx}, ..., \textrm{right_idx} ] \) is sorted in ascending order
    </div>
    <div class="proof"></div>
</div>
<div class="theorem" id="theorem-merge-sort-is-correct">
    <div class="title">
        \( \texttt{merge_sort} \) is Correct
    </div>
    <div class="content">
        Given any list, merge sort correctly sorts it in place
    </div>
    <div class="proof"></div>
</div>
