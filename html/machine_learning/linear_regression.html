<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Linear Regression</title>

  <link rel="stylesheet" href="/styles/styles.css">
  <script src="/js/script.js" defer></script>

</head>

<body>
  <div class="thin-wrapper">

    <!-- 
  Write what you did for the night here, and I'll commit with this message when I get back:

  
  ccn: added link to linear regression page, created graphic, helped write example, figrued out connections between 1x1 matrices and real numbers (check whiteboard for that)
  
  jy: formally defined linear regression model, motivated loss/cost functions, defined optimal w and b
  
  nk: Made an example for linear regression, drew out proof for chain rule using binomial theorem on white board... next time will continue chain rule definition
  -->

    <h1>Linear Regression</h1>

    <h2>Introduction</h2>

    \(
    \def\R{{\mathbb{R}}}
    \def\N{{\mathbb{N}}}
    \def\bold#1{{\bf #1}}
    \)

    <p>
      Before getting started with linear regression, let's brings things down to a simpler level, let's say you had some
      graph paper and and a bunch of dots on it, if you wanted to draw a line that best approximates the location of all
      the points, mentally you could probably do this by seeing which areas
    </p>

    <div class="centered-content">
      <img src="graphics/line_of_best_fit.jpg" alt="Line of best fit" width="500">
    </div>

    <p>
      Line of best fit is a function which is plotted to minimize a distance between data points, with the aim of
      closely approximating the data set.
      It is often used to show a trend / correlation between a dependant variable and an independant variable.
      In terms of linear regression, when working in \( \R^2 \), it is in the form: \(y = mx + b \)
    </p>

    <h2>Generalized</h2>

    <div>
      <p>
        Suppose that \( N, D \in \N \), where \(D \) is used to represent the dimension of our input of and \( N \) is
        the number of data points in the dataset. Then given a dataset \( \mathcal{D} = \{(\textbf{x}^{(1)}, y^{(1)}),
        \ldots, (\textbf{x}^{(N)}, y^{(N)})\} \subseteq \R^D \times \R \) <b>the goal of linear regression</b> is to
        find a <a class="knowledge-link" href="/fundamentals/functions.html#definition-function">function</a> \( f :
        \R^D \rightarrow \R \) of the form \( f(\textbf{x}) = \textbf{w}\cdot\textbf{x} + b \),
        where \( \textbf{w} \in \R^D \) and \( b \in \R \) (note that here we're combining the two vectors using the <a
          class="knowledge-link" href="/algebra/linear/vectors.html#definition-dot-product">dot product</a>) that best
        represents our dataset (we will get to that soon).
      </p>
      <p>
        <!-- Each \( (\textbf{x}^{(i)}, y^{(i)}) \) represents a data point, where \( \textbf{x}^{(i)} \) contains the <i>features</i> describing that data point and \( y^{(i)} \) is the <i>label</i> we want to predict. -->

      <details>
        <summary>Example</summary>
        <fieldset>
          <legend>Apple Growing</legend>
          <p>
            <b>Example:</b> Suppose that \( D = 2 \), and that \( N = 5 \), and that we're modelling the situation where
            a point \( (x, y) \in \R^2 \) is composed of \(x \), which represents the number of years since 2005, and
            the \( y \) represents the average temperature (in celcius) of your local city, then the 3rd component is
            the number of apples that you grown that year. The plane of best fit would show a trend if there is a
            correlation between the number of years since 2005, the average temperature, and the number of apples grown.
          </p>

          <p>
            In this situation our dataset could look like : \( \mathcal{D} = \{((1,20),7), ((3,18),3), ((2,25),8),
            ((5,19),12), ((7,24),15)\} \subset \R^2 \times \R \)
          </p>
          Our goal is to write a function \(f(x) = w \cdot x + b\) (by picking values for \(w \in \R^D \) and \( b \in
          \R \)) where this function takes in a a year since 2005, the average temperature in the local city, and
          predicts the number of apples that should be grown that year.
          <p>
        </fieldset>

      </details>

      <p>
        Here \( f \) is parameterized by \( \textbf{w} \) and \( b \), where \( \textbf{w} \) is called the
        <i>weights</i> of \( f \), and \( b \) is called the <i>bias</i> of \( f \). Different \( \textbf{w} \) and \( b
        \) will lead to different \( f \), so we want to find \( \textbf{w} \) and \( b \) that will lead to \( f \)
        representing the dataset in the "best" way possible. To quantify how well \( f \) represents the dataset, we can
        define a <i>loss function</i> \( \mathcal{L} : \R \times \R \rightarrow \R \).
      </p>

      <p>
        In the case of linear regression, a common loss function is the <i>squared error</i>, which is defined as:
        \[ \mathcal{L}(\hat{y}, y) = \frac{1}{2}(\hat{y} - y)^2 \]
        Intuitively, the squared error measures the difference between the predicted label, denoted \( \hat{y} \), where
        \( \hat{y} = f(\textbf{x}) \), and the actual label, denoted \( y \), which is then squared and halved for the
        sake of computational convenience during differentiation. If \( \hat{y} \) is close to \( y \), then the squared
        error is small, and if \( \hat{y} \) is far from \( y \), then the squared error is large. So, the squared error
        can be interpreted as a measure of how poorly \( f \) predicted \( y \). Furthermore, because of the exponent,
        the squared error exaggerates how poorly \( f \) predicted \( y \) when the difference between them is large. We
        can calculate the <i>mean squared error</i> over all data points in the dataset to measure how poorly \( f \)
        predicted all \( y \), which is defined as:

        \[\frac{1}{2N}\sum_{i=1}^N \left(\hat{y}^{(i)} - y^{(i)}\right)^2\]
      </p>

      <p>
        Naturally, the best \( \textbf{w} \) and \( b \) will be the ones that yield the smallest mean squared error. This is essentially an optimization problem, where we want to find the values of \( \textbf{w} \) and \( b \) that minimize the mean squared error. The mean squared error is commonly referred to as the <i>objective function</i>, since as the name suggests, it is the objective we want to minimize.
      </p>

      <p>
        For convenience, we can redefine \( \textbf{x} \) as \( (1, x_1, \dots, x_n) \) and \( \textbf{w} \) as \( (b, w_1, \dots, w_D) \) so that our linear regression model can be written as simply \( f(\textbf{x}) = \textbf{w} \cdot \textbf{x} \). Now, we only have to find the best \( \textbf{w} \). Formally, we are interested in finding:
        \[ \underset{\textbf{w}}{\text{argmin}} \frac{1}{2N}\sum_{i=1}^N \left(\hat{y}^{(i)} - y^{(i)}\right)^2\ \]
      </p>
      
      <h2>Vectorization</h2>
      <p>
        For computational efficiency, we can represent \( \{\textbf{x}^{(1)}, \ldots, \textbf{x}^{(N)}\} \) as a <i>design matrix</i>, denoted \( \textbf{X} \), defined
        as follows.
        \begin{bmatrix}
        1 & x_1^{(1)} & x_2^{(1)} & \cdots & x_D^{(1)} \\
        1 & x_1^{(2)} & x_2^{(2)} & \cdots & x_D^{(2)} \\
        \vdots & \vdots & \vdots & \ddots & \vdots \\
        1 & x_1^{(N)} & x_2^{(N)} & \cdots & x_D^{(N)}
        \end{bmatrix}

        Similarly, we can represent \( \{y^{(1)}, \ldots, y^{(N)}\} \) as a matrix too, denoted \( \textbf{y} \), defined as follows.
        \begin{bmatrix}
        y^{(1)} \\
        y^{(2)} \\
        \vdots \\
        y^{(N)}
        \end{bmatrix}

        By organizing \( \mathcal{D} \) as a matrix, we can express our computations in terms of matrix operations. This is particularly useful since modern GPUs are specialized to perform matrix operations in parallel, which significantly speeds up computations. Furthermore, matrices allow us to express computations on our dataset in a concise and simple language.
      </p>

      <h2>Gradient Descent</h2>

      <h3>Batch Gradient Descent</h3>
      <p>
        <!-- TODO: move gradient descent to bottom -->
        If an analytical solution is not available, we can use iterative approximation techniques like <i>gradient descent</i> to compute an estimate for the best \( \textbf{w} \). The basic idea of gradient descent is to initialize \( \textbf{w}_0 \) to some element in \( \R^{D + 1} \) at time step 0 and iteratively adjust \( \textbf{w}_t \) in the direction opposite to the gradient of the objective function at \( \textbf{w}_t \) at time step \( t \geq 1 \). 

        \[ \textbf{w}_t \gets \textbf{w}_{t-1} - \alpha \nabla \mathcal{J}(\textbf{w}_{t-1}) \text{, where } \alpha \in \R \]

        The gradient points in the direction of steepest ascent (TODO: PROVE WHY), so the direction opposite to the gradient is the direction of steepest descent. Following the direction of steepest descent will eventually lead to a local minimum. If the objective function is <i>convex</i>, then that local minima will also be the global minimum (TODO: PROVE WHY). 
      </p>
      <p>
        The <i>learning rate</i> \( \alpha \) controls how much we adjust \( \textbf{w}_t \) during each iteration. Large values of \( \alpha \) mean we take large "steps" down the objective function landscape, leading to potentially fast but coarse searches. In contrast, small values of \( \alpha \) mean we take small "steps" instead, leading to slow but fine searches.
      </p>
      <details>
        <summary>In the context of linear regression...</summary>
        <fieldset>
          <p>
            Assume our objective function is the mean squared error. Then, our gradient descent update rule would be:
            \[ \textbf{w}_t \gets \textbf{w}_{t-1} - \alpha \frac{1}{N}\textbf{X}^\top(\textbf{Xw}_{t - 1} - \textbf{y}) \]
          </p>
        </fieldset>
      </details>
      <p>
        TODO: pros vs. cons of different types of initializations of \( \textbf{w}_0 \). Stopping condition: convergence criterion, maximum number of iterations. Pitfalls.
      </p>

      <h3>Stochastic Gradient Descent (SGD)</h3>
      <p>

      </p>

      <h3>Mini-Batch Gradient Descent</h3>
      <p>
        
      </p>

      <h3>TODO: Momentum, Adagrad, RMSprop, Adam</h3>

      </p>
    </div>

    <h2>Finding Our Weights</h2>

    <p>
      Now we'll focus our attention on how to actually find these weights. Up until now, we've mainly just considered things from a purely mathematical standpoint. But process of determining these weights is a perfect one for a computer to solve
    </p>

    <p>
      Even now we can already come up with a brute force algorithm which would be to iterate through a large finite set of weight options and just pick the weights that result in a small mean squared error. This process is already to computationally heavy for a human to perform.
    </p>

    <p>
      Even though our brute force solution will eventually provide us a good set of weights. If we want a more optimized set of weights we'll have to increase the resolution of our weight space which will have huge impacts on the computational time taken and will probably bring our program to a grinding halt.
    </p>

    <p>
      Instead of coming up with a method and seeing if it will work well with our computer, let's flip the problem. We know computers are good at simple arithmetic and iterating quickly this makes them perfect to perform operations involving matrices. With this in mind we'll jump into two methods to solve for our weights.
    </p>

    <h3>The Ad Hoc Method</h3>

    <p>
      Sometimes when you see a question or a math problem you see something and you try it, sometimes this will work and sometimes not, this is why it's ad hoc, when trying to minimize our weights we can come up with such a method.
    </p>

    <p>
      If you recall our goal is to find for what values \( w \) we have \( \nabla \mathcal{J} \left( w \right) = 0 \)
    </p>

    <p>
      Before we jump into these calculations, recall the definition of \( \operatorname{pack} \left( x \right) : \mathbb{R} \rightarrow M_{1 \times 1} \left( \mathbb{R} \right) \) and that \( \operatorname{pack} \left( a \right) = \operatorname{pack} \left( b \right) \iff a = b\) for all \( a, b \in \mathbb{R} \). In general the \( \operatorname{pack} \left( x \right) \) function is useful because it can allow us to take a mathematical equation and turn it into a question about matrices, which our computer will thank us for.
    </p>

    \[
      \begin{aligned}
        \operatorname{pack} \left( \mathcal{J} \left( w \right) \right) &= \operatorname{pack} \left( \frac{1}{2N}\sum_{i=1}^N \left(\hat{y}^{(i)} - y^{(i)}\right)^2 \right) \\
        &= \frac{1}{2N} \operatorname{pack} \left( \sum_{i=1}^N \left(  \mathbf{w} \cdot \mathbf{x}^{(i)} - y ^{(i)} \right)^2 \right) \\
        &= \frac{1}{2N} 
        \begin{bmatrix}
          \mathbf{x}^{(1)} \cdot \mathbf{w} - y^{(1)} \\
          \mathbf{x}^{(2)} \cdot \mathbf{w} - y^{(2)} \\
          \vdots \\
          \mathbf{x}^{(N)} \cdot \mathbf{w} - y^{(N)} \\
        \end{bmatrix}^\mathsf{T}
        \begin{bmatrix}
          \mathbf{x}^{(1)} \cdot \mathbf{w} - y^{(1)} \\
          \mathbf{x}^{(2)} \cdot \mathbf{w} - y^{(2)} \\
          \vdots \\
          \mathbf{x}^{(N)} \cdot \mathbf{w} - y^{(N)} \\
        \end{bmatrix} \\
        &= \frac{1}{2N} \left( \mathbf{X} \mathbf{w} - \mathbf{y} \right)^\mathsf{T} \left( \mathbf{X} \mathbf{w} - \mathbf{y} \right) \\
        &= \frac{1}{2N} \left( \left( \mathbf{X} \mathbf{w} \right)^\mathsf{T} - \mathbf{y}^\mathsf{T} \right) \left( \mathbf{X} \mathbf{w} - \mathbf{y} \right) \\
        &= \frac{1}{2N} \left( \left( \mathbf{X} \mathbf{w} \right)^\mathsf{T} \mathbf{X} \mathbf{w} - \left( \mathbf{X} \mathbf{w} \right)^\mathsf{T} \mathbf{y}  - \mathbf{y}^\mathsf{T} \mathbf{X}\mathbf{w} + \mathbf{y}^\mathsf{T} \mathbf{y}\right) \\
        &= \frac{1}{2N} \left( \mathbf{w}^\mathsf{T} \mathbf{X}^\mathsf{T} \mathbf{X} \mathbf{w} - 2 \mathbf{w}^\mathsf{T} \mathbf{X}^\mathsf{T} \mathbf{y} + \mathbf{y}^\mathsf{T} \mathbf{y}\right) \\
        &= \frac{1}{2N} \mathbf{w}^\mathsf{T} \mathbf{X}^\mathsf{T} \mathbf{X} \mathbf{w} - \frac{1}{N}\mathbf{w}^\mathsf{T} \mathbf{X}^\mathsf{T} \mathbf{y} + \frac{1}{2N} \mathbf{y}^\mathsf{T} \mathbf{y}
      \end{aligned}
    \]
    <p>
      Note that here we've used the following facts about matrix multiplication
    </p>
    <ul>
      <li>\(  \left( \mathbf{X} \mathbf{w} \right) ^ \mathsf{T} \mathbf{y} = \mathbf{y} ^ \mathsf{T} \mathbf{X} \mathbf{w}     \) </li>
      <li>
        \( \left( A + v \right) \left( B + w \right) = A B + A w + B v + v w   \), note that the dimensions must match for this to occur
      </li>
    </ul>
    <p>
      Now we continue by taking the gradient of this with respect to \( \mathbf{w}  \) to obtain 
      \[
          \frac{\partial }{\partial \mathbf{w} } \mathcal{ J } \left( \mathbf{w}  \right) = \frac{1}{N} \mathbf{X} ^ \mathsf{T} \mathbf{X} \mathbf{w}  - \frac{1}{N} \mathbf{X} ^ \mathsf{T} \mathbf{y} 
      \]
    </p>
    <p>
      Here we've used the facts:
    </p>
    <ul>
      <li>
        We can take the derivative of a function which produces a box, by instead taking the derivative of the contents of that box and then putting it in a box, that is to say if \( f : \mathbb{ R } ^ n \to M _ { 1 \times 1 } \left( \mathbb{ R }  \right)   \), then we define \( f ^ \star \left( \mathbf{x}  \right) = \operatorname{ unpack } \left( f \left( \mathbf{x}  \right)  \right)   \)  \( \frac{\partial}{\partial \mathbf{x} }  f \left( \mathbf{x}  \right) := \operatorname{ pack } \left( \frac{\partial}{\partial \mathbf{x} } f ^ \star \left( \mathbf{x}  \right)  \right) \)
      </li>
      <li>
        \( \frac{\partial }{\partial \mathbf{w}  } \mathbf{w}  \cdot \mathbf{x} = \textbf{ x }  \). Proof: \( \frac{\partial }{\partial \mathbf{w} _ i} \mathbf{w} \cdot \mathbf{x} = \frac{\partial }{\partial \mathbf{w} _ i } \sum _ { j = 1 }  ^ n w _ j x _ j = w _ j  \)
      </li>
      <li>
        \( \frac{\partial }{\partial \mathbf{w} } \left( \mathbf{X} \mathbf{w} \right) \mathbf{w} = 2 \left( \mathbf{X} \mathbf{w}  \right)   \)
      </li>
    </ul>
    <p>
      Therefore by setting the gradient to zero we can explicitly solve for \( \mathbf{w}  \) so we have 
      \[
          \begin{gather}

             \frac{1}{N} \mathbf{X} ^ \mathsf{T} \mathbf{X} \mathbf{w}  - \frac{1}{N} \mathbf{X} ^ \mathsf{T} \mathbf{y} = 0 \\
      \Updownarrow \\
            \mathbf{X} ^ \mathsf{T} \mathbf{X} \mathbf{w}  - \mathbf{X} ^ \mathsf{T} \mathbf{y} = 0  \\
      \Updownarrow \\
              \mathbf{X} ^ \mathsf{T} \mathbf{X} \mathbf{w} = \mathbf{X} ^ \mathsf{T} \mathbf{y} \\
      \Updownarrow \\
          \mathbf{w} = \left( \mathbf{X} ^ \mathsf{T} \mathbf{X}  \right) ^ { -1 } \mathbf{X} ^ \mathsf{T} \mathbf{y}
      \end{gather}
      \]
      which can only be carried out so long as \( \left( \mathbf{X} ^ \mathsf{T} \mathbf{X}  \right) ^ { -1 }   \) exists, and thus we conclude that the weights that minimize \( \mathcal{ J } \left( w \right)  \) are given by this expression.
    </p>
  </div>
</body>

</html>