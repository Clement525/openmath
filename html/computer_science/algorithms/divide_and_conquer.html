<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Divide and Conquer</title>
    <link rel="stylesheet" href="../../styles/styles.css">
    <script src="/js/script.js" defer></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/woodland.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script src="moz-extension://5d794e46-29d2-4a1a-a13b-4b3d120abe5c/content/fido2/page-script.js"></script>

    <script>hljs.highlightAll();</script>

    <script src="/js/insert_file_contents.js"></script>
</head>

<body>
<div class="thin-wrapper">

    <p>
        Many useful algorithms have a recursive structure. A common pattern that comes up is solving a problem by first breaking down the initial problem into two or more sub-problems which can be solved recursively, and then finally combining the two sub-problems together. Note that not all problems can be solved in this way
    </p>

    <div class="definition" id="definition-divide-and-conquer">
    	<div class="title">Divide and Conquer</div>
    	<div class="content">
    		An algorithm that solves a problem by recursively solving subproblems and then re-combining them is said to be a <b>divide and conquer</b> algorithm.
    	</div>
    </div>

    <div class="code-file" data-file-name="implementation/merge_sort.cpp"></div>
    
    <div class="lemma" id="lemma-merge-is-correct">
    	<div class="title">\( \texttt{merge} \)  is Correct</div>
    	<div class="content">
            Given an array \( A \) and indices \( \textrm{left_idx}, \textrm{split_idx}, \textrm{right_idx} \) such that the subarrays \( A [ \textrm{left_idx}, ..., \textrm{split_idx} ], A [ \textrm{split_idx + 1}, ..., \textrm{right_idx} ]  \) are already sorted in ascending order then after merge sort has terminated, then the subarray \( A[ \textrm{left_idx}, ...,  \textrm{right_idx} ] \) is sorted in ascending order
    	</div>
    	<div class="proof">

    	</div>
    </div>
    

    <div class="theorem" id="theorem-merge-sort-is-correct">
    	<div class="title">\( \texttt{merge_sort} \)  is Correct</div>
    	<div class="content">
    	    Given any list, merge sort correctly sorts it in place
    	</div>
    	<div class="proof">

    	</div>
    </div>


    <div class="code-file" data-file-name="implementation/counting_inversions.cpp"></div>


    <div class="lemma" id="lemma-inversion-lookahead-sorted-concatenation">
        <div class="title">Inversion Lookahead in Sorted Concatenation</div>
        <div class="content">
            Suppose that \( a = \left( a _ 1, \ldots , a _ n \right) \) and \( b = \left( b _ 1, \ldots , b _ m \right)  \)  are finite tuples sorted in ascending order and define \( c = \operatorname{ concat } \left( a, b \right)  \). If \( a _ i \) and \( b _ j \) form an inversion then for every \( k \in [ i \ldots n ]  \) \( a _ k \) and \( b _ j \) form an inversion in \( c \)
        </div>
        <div class="proof">
            <p>
                Before the proof starts note that \( c \)  has \( n + m \) elements, and then \( b _ j \) refers to the element at position \( n + j \) with respect to \( c \)
            </p>
            <p>
                We know that \( b _ j \lt a _ i \) because they form an inversion, we also know that \( a \) is sorted in ascending order, therefore we know that \( b _ j \lt a _ i \lt a _ { i + 1 } \lt  \ldots \lt a _ n  \), therefore for each \( k \in [ i ... n ]  \) we know \( \left( k, n + j  \right) \)  forms an inversion in \( c \) as needed.
            </p>
        </div>
    </div>

    <div class="lemma" id="lemma-no-inversion-lookahead-in-sorted-concatenation">
        <div class="title">No Inversion Lookahead in Sorted Concatenation</div>
        <div class="content">
            Suppose that \( a = \left( a _ 1, \ldots , a _ n \right) \) and \( b = \left( b _ 1, \ldots , b _ m \right)  \)  are finite tuples sorted in ascending order and define \( c = \operatorname{ concat } \left( a, b \right)  \). If \( a _ i \) and \( b _ j \) do not form an inversion then for every \( k \in [ j \ldots m ]  \) \( a _ i \) and \( b _ k \) do not form an inversion in \( c \)
        </div>
        <div class="proof">
            Since \( a _ i \) and \( b _ j \) do not form an inversion then we know that \( a _ i \le b _ j \), since \( b \) is sorted in ascending order then we know that \( a _ i \le b _ j \le b _ { j + 1 } \le \ldots \le b _ m \), and thus for every \(  k \in [ j \ldots m]   \) we know \( a _ i \) and \( b _ k \) do not form an inversion.
        </div>
    </div>

    <div class="proposition" id="proposition-counting-inversions-is-correct">
    	<div class="title">\( \texttt{counting_inversions} \) is Correct</div>
    	<div class="content">
    	    Given any list \( A \)  \( \texttt{counting_inversions} \) returns the number of <a class="knowledge-link" href="/fundamentals/sets/tuples.html#definition-inversion">inversions</a> in \( A \)
    	</div>
    	<div class="proof">
    		
    	</div>
    </div>
    


</div>
</body>
