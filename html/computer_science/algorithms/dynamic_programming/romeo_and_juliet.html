<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Missing Number</title>
  <link rel="stylesheet" href="../../../styles/styles.css">
  <script src="/js/script.js" defer></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/woodland.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script src="moz-extension://5d794e46-29d2-4a1a-a13b-4b3d120abe5c/content/fido2/page-script.js"></script>

  <script>hljs.highlightAll();</script>

  <script src="/js/insert_file_contents.js"></script>
</head>

<body>
<div class="thin-wrapper">

    <h1>Romeo and Juliet</h1>

    <p>
    Juliet has a secret to tell Romeo. However, every message that Juliet sends to Romeo needs to be examined by Capulet, Juliet's father. So Juliet decides to encrypt the message such that Capulet cannot understand easily. To simplify the problem, suppose there are only three letters in Juliet's alphabet \( \Sigma = \{ a , b, c \} \). Juliet defines a mapping \( f : \Sigma \to \{0,1\}^* \), where \( f(a) = 0, f(b) = 01, f(c) = 11 \) . Suppose Juliet wants to send a message \( m \in \{ a, b, c \}^k \). She sends the encrypted message \( f(m) = f(m_1) \circ f(m_2) \circ ... \circ f(m_k) \) , where \( m_i \) is the \( i \) th character of $m$, and \( \circ \) means concatenation.
    </p>

    <ol>
        <li>Given \( f(m) = 1101100110001110 \), how many possible messages are there, and what are they? (No justification required)</li>
        <li>Design a dynamic programming algorithm using memoization technique that decrypts any encrypted message \( s \) sent by Juliet. Your algorithm should return the original message \( m \) where \( f(m) = s \). If the pre-image \( f^{-1}(s) \) does not exist, return \( {\tt JUNK} \). Sometimes, Juliet sends meaningless junk to confuse her father.</li>
        <li>What is the time and space complexity of your algorithm? Briefly explain why.</li>
        <li>Consider \( \Sigma = \{ a, b, c, d\} \), and the mapping \( f: \Sigma \to \{0,1\}^* \) is now \( f(a) = 0, f(b) = 01, f(c) = 011, f(d) = 1110 \). Is there a greedy algorithm to decrypt messages encrypted by this mapping? Briefly explain why.</li>
    </ol>
    <hr>

    <h3>1</h3>

    <p>
    Given the string \( 1101100110001110 \) and assuming that it can be decoded to at least one input string, then specifically there is only one way to decode this message, this is true because we can observe, that the sequence of characters \( 110 \) can only ever be decoded to \( c 0 \) this is because there is only one way to produce two \( 1 \)'s in a row.
    </p>

    <p>
    Therefore we can decode the string to \( c0c00c0001c0 \), now we can decode any \( 01 \)'s we find which would be decoded to \( b \) so we obtain \( c0c00c00bc0 \), now the rest can only be \( a \)'s, to obtain a final decoding of \( cacaacaabca \)
    </p>

    <p>
    On top of all this, we actually note that it is a uniquely decodeable encoding, which means that given any encrypted string there is one way to decode it or no way to decode it.
    </p>


    <h3>2</h3>

    <p>
    Firstly note that we can pretty easily do this without dynamic programming by taking a right to left approach:
    </p>

    <pre>
    decrypt(m):
        if len(m) >= 2
            if m[-2:] == "11"
                return decrypt(m[-2:]) o "c"
            if m[-2:] == "01":
                return decrypt(m[-2:]) o "b"
            if m[-1] == "0"
                return decrypt(m[-1]) o "a"
        if len(m) == 1:
            if m = "0" return a
            else return JUNK
        if len(m) == 0:
            return ""
    </pre>

    <p>
        Recall that for any given prefix free encoding we can left to right greedily decode it, therefore for any postfix free encoding we can right to left greedily decode it. Since the given encryption scheme was postfix free, this is why we were able to come up with the above greedy algorithm.
    </p>

    <p>
    Nonetheless, let's come up with a dynamic programming approach. We can do this by noting the optimal substructure property by attempting to decode from left to right, where we note the following:
    </p>

    <ul>
        <li>If the first two chars are "00", then the first character may be decoded to \( b \) </li>
        <li>If the first two chars are "01", then it's not possible to immediately decrypt this because it's possible that the string is "011", which would decode to \( ac \), on the other hand it's also possible the entire string is "0111" which would decrypt to \( bc \)</li>
    </ul>

    <p>
    The second case, leads to two cases, one where we first assume that the "0" gets decoded to \( a \) and a second where the "01" gets decode to \( b \), with this split, we now take advantage of the fact that we know that there is a either a unique encoding or no encoding. So if we assume "0" decodes to \( b \) and try and decode the rest of the string, this will either result in a decoded string, or JUNK, the same is true if we assume that "01" gets decoded to \( b \), but note that in this case, there is only three possibilities, either the former returns a decoded string and the latter JUNK, or the former returns JUNK and the latter a decoded string, or both the former and the latter both return JUNK, which means the entire string cannot be decrypted.
    </p>

    <p>
    We'll now specify the bellman equation as pseudocode, as nested piecewise functions don't yield the most readable syntax.
    </p>

    <pre>
    decrypt(m):
        if len(m) >= 2:

            first_two = m[:2]
            if first_two == "00"
                return "b" o decrypt(m[1:])

            if first_two == "11"
                return "c" o decrypt(m[2:])

            if first_two == "01":
                rec_attempt_a = decrypt(m[1:])
                rec_attempt_b = decrypt(m[2:])

                # we know exactly one of these if statements will be true
                if rec_attempt_a != JUNK:
                  return "a" o rec_attempt_a
                elif rec_attempt_b != JUNK:
                  return "b" o rec_attempt_b
                else: # both junk
                  return JUNK

        if len(m) == 1:
            if m = "0":
              return a
            else:
              return JUNK

        if len(m) == 0:
            return ""
    </pre>

    <p>
        Now we'll write the code which implements this, which starts at the right of a encoded string and moves leftward, re-using any solutions it found previously
    </p>

    <pre>
        Let N = len(m) - 1
        Let K be a fixed array of length len(m) where K[i] represents the decryption of m[ N - i : N]
        decode_bottom_up(m: str):
            cur_mes = ""
            for i in len(m):
                j = (m - 1) - i # the goal is to grab the rightmost char
                cur_mes = m[j] + cur_mes

                if len(cur_mes) >= 2:

                    first_two = cur_mes[:2]
                    if first_two == "00"
                        return "b" o K[i - 1]

                    if first_two == "11"
                        return "c" o K[i - 2]

                    if first_two == "01":
                        rec_attempt_a = K[i - 1]
                        rec_attempt_b = K[i - 2]

                        # we know exactly one of these if statements will be true
                        if rec_attempt_a != JUNK:
                          K[i] = "a" o rec_attempt_a
                        elif rec_attempt_b != JUNK:
                          K[i] =  "b" o rec_attempt_b
                        else: # both junk
                          K[i] = JUNK

                if len(cur_mes) == 1:
                    if m = "0":
                      K[i] = "a"
                    else:
                      K[i] = JUNK

                if len(m) == 0:
                    return ""

            return K[len(m) - 1]
    </pre>

    <h3>3</h3>

    <p>
        Clearly, there are exactly \( n \) iterations where \( n \) is the length of the list, each iteration costs a constant amount of time, because it falls into one of the if clauses, and does some assignments or uses a previously computed K value. Thus the runtime is \( \Theta \left( n \right)  \).
    </p>

    <p>
        Consider the encoding "000...000", in this case each K value will be an increasing number of sequential \( a \)'s which would lead to space \( \mathcal{ O } \left( n ^ 2 \right)  \) to store the previous solutions. We can correct for this by noting that we only need to reference a postfix with length one or two smaller than our current, allowing us to throw away anything smaller, therefore our space complexity can be reduced to \( \mathcal{ O } \left( 2 n \right) = \mathcal{ O } \left( n \right)   \) .
    </p>

    <h3>4</h3>

    <p>
        We claim that there is a greedy method to decode this. Let's first observe the following facts
    </p>

    <ul>
        <li>if "...1110..." is ever observed then it will be decoded to "...\( d \)..." </li>
        <li>if "...0110..." is ever observed it will be decoded to "...\( c \)0..."</li>
        <li>if "...010..." is ever observed it will be decoded to "...\( b \)0..."</li>
        <li>if "...000..." is ever observed it will be decoded to "...0\( a \)0..."</li>
    </ul>

    <p>
        Therefore given any valid encoding, we simply use the above substitution rules greedily, each of which strictly reduce the number of encrypted characters, we would also use the rule that if we have decrypted the string "1110010111" to the point "\( d \) 01 \( c \)", we can also decrypt and individual encryption, so to get \( dbc \).
    </p>

    <p>
        The above works but is not very constructive, so we can also specify a right to left greedy algorithm:
    </p>

    <pre>
        decypt(m):
            if len(m) >= 4:
                if m[-4:] = "1110"
                    return decrypt(m[-4:]) o "d"

            if len(m) >= 3:
                if m[-3:] = "011"
                    return decrypt(m[-3:]) o "c"

            if len(m) >= 2:
                if m[-2:] = "01":
                    return decrypt(m[-2:]) o "b"

            if len(m) >= 1:
                if m[-1] == "0":
                    return decrypt(m[-1:]) o "a"

            if len(m) == 0:
                return ""

    </pre>

    <p>
        Note that the reason why the above works is that if we recall from before given a prefix free encoding, we can greedily decode it from left to right, on the other side of that coin, if we have a postfix free encoding, we can decrypt it from right to left. In our given ecryption scheme, we note that they are mostly prefix free aside from "0" and "1110", and we can deal with this collision by first checking if the string has length at least 4, and it's last four characters are "1110", otherwise if it ends in a "0" it must be in the other case, which guarentees correctness of our "if len(m) >= 1" branch.
    </p>






</div>
</body>
